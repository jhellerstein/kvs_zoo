//! KVS architectural layering pattern.
//!
//! This module provides the core pattern for composing KVS architectures from
//! layers of dispatch and maintenance strategies. Each layer pairs a dispatch
//! strategy (how to route operations) with a maintenance strategy (how to keep
//! replicas in sync), and can nest recursively.
//!
//! ## Example
//!
//! ```ignore
//! struct Shard;
//! struct Replica;
//!
//! type MyKVS = KVSCluster<
//!     Shard,
//!     ShardedRouter,
//!     (),
//!     KVSCluster<Replica, RoundRobinRouter, BroadcastReplication, ()>
//! >;
//! ```

use crate::dispatch::OpDispatch;
use crate::maintenance::ReplicationStrategy;
use crate::protocol::KVSOperation;
use hydro_lang::location::cluster::Cluster;
use hydro_lang::prelude::*;
use std::any::TypeId;
use std::collections::HashMap;
use std::marker::PhantomData;

/// A layer in the KVS architecture, pairing dispatch and maintenance strategies.
///
/// - `Name`: marker type naming this layer (shared with Hydro location types)
/// - `D`: dispatch strategy at this level
/// - `M`: maintenance strategy at this level
/// - `Child`: either another `KVSCluster` or `()` for terminal
#[derive(Clone)]
pub struct KVSCluster<Name, D, M, Child> {
    _name: PhantomData<Name>,
    pub dispatch: D,
    pub maintenance: M,
    pub child: Child,
}

impl<Name, D, M, Child> KVSCluster<Name, D, M, Child> {
    pub fn new(dispatch: D, maintenance: M, child: Child) -> Self {
        Self {
            _name: PhantomData,
            dispatch,
            maintenance,
            child,
        }
    }
}

impl<Name, D: Default, M: Default, Child: Default> Default for KVSCluster<Name, D, M, Child> {
    fn default() -> Self {
        Self::new(D::default(), M::default(), Child::default())
    }
}

/// Collection of named cluster handles created during KVS wiring.
///
/// Allows type-safe lookup of cluster handles by layer name.
pub struct KVSClusters<'a> {
    clusters: HashMap<TypeId, Cluster<'a, crate::kvs_core::KVSNode>>,
    aux_clusters: HashMap<TypeId, Box<dyn std::any::Any + 'a>>, // proposer/acceptor or other aux types
}

impl<'a> KVSClusters<'a> {
    pub fn new() -> Self {
        Self {
            clusters: HashMap::new(),
            aux_clusters: HashMap::new(),
        }
    }

    /// Insert a cluster handle for a named layer.
    pub fn insert<Name: 'static>(&mut self, cluster: Cluster<'a, crate::kvs_core::KVSNode>) {
        self.clusters.insert(TypeId::of::<Name>(), cluster);
    }

    /// Get the cluster handle for a named layer.
    ///
    /// Panics if the layer name was not registered during wiring.
    pub fn get<Name: 'static>(&self) -> &Cluster<'a, crate::kvs_core::KVSNode> {
        self.clusters
            .get(&TypeId::of::<Name>())
            .unwrap_or_else(|| panic!("No cluster found for layer type {}", std::any::type_name::<Name>()))
    }

    /// Try to get the cluster handle for a named layer.
    pub fn try_get<Name: 'static>(&self) -> Option<&Cluster<'a, crate::kvs_core::KVSNode>> {
        self.clusters.get(&TypeId::of::<Name>())
    }

    /// Insert an auxiliary cluster (non-KVSNode typed) by concrete type.
    pub fn insert_aux<T: 'static>(&mut self, cluster: Cluster<'a, T>) {
        self.aux_clusters
            .insert(TypeId::of::<T>(), Box::new(cluster));
    }

    /// Get an auxiliary cluster by type.
    pub fn get_aux<T: 'static>(&self) -> &Cluster<'a, T> {
        self.aux_clusters
            .get(&TypeId::of::<T>())
            .and_then(|b| b.downcast_ref::<Cluster<'a, T>>())
            .unwrap_or_else(|| panic!("No auxiliary cluster found for type {}", std::any::type_name::<T>()))
    }

    pub fn try_get_aux<T: 'static>(&self) -> Option<&Cluster<'a, T>> {
        self.aux_clusters
            .get(&TypeId::of::<T>())
            .and_then(|b| b.downcast_ref::<Cluster<'a, T>>())
    }
}

impl<'a> Default for KVSClusters<'a> {
    fn default() -> Self {
        Self::new()
    }
}

/// Trait for KVS specifications that can create and register clusters.
pub trait KVSSpec<V> {
    /// Create clusters for this layer and all child layers, registering them in the layers map.
    /// Returns the cluster that should receive operations FROM this layer (i.e., the child's entry point).
    fn create_clusters<'a>(
        &self,
        flow: &hydro_lang::compile::builder::FlowBuilder<'a>,
        layers: &mut KVSClusters<'a>,
    ) -> Cluster<'a, crate::kvs_core::KVSNode>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static;
}


/// Trait to wire routing across layers using per-layer dispatchers.
///
/// Provides methods to route operations from a proxy process into the first
/// cluster, and then recursively from cluster to cluster for nested layers.
pub trait KVSWire<V> {
    fn wire_from_process<'a>(
        &self,
        layers: &KVSClusters<'a>,
        operations: Stream<KVSOperation<V>, Process<'a, ()>, Unbounded>,
    ) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static;

    fn wire_from_cluster<'a>(
        &self,
        layers: &KVSClusters<'a>,
        source_cluster: &Cluster<'a, crate::kvs_core::KVSNode>,
        operations: Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>,
    ) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static;
}

impl<V> KVSWire<V> for () {
    fn wire_from_process<'a>(
        &self,
        _layers: &KVSClusters<'a>,
        _operations: Stream<KVSOperation<V>, Process<'a, ()>, Unbounded>,
    ) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    {
        panic!("Root layer cannot be terminal '()'; provide at least one KVSCluster.");
    }

    fn wire_from_cluster<'a>(
        &self,
        _layers: &KVSClusters<'a>,
        _source_cluster: &Cluster<'a, crate::kvs_core::KVSNode>,
        operations: Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>,
    ) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    {
        operations
    }
}

// (Leaf case handled by the recursive impl via Child = () implementing KVSWire)

// Recursive (non-leaf) implementation.
impl<V, Name, D, M, Child> KVSWire<V> for KVSCluster<Name, D, M, Child>
where
    Name: 'static,
    V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    D: OpDispatch<V> + Clone,
    M: ReplicationStrategy<V> + Clone,
    Child: KVSWire<V>,
{
    fn wire_from_process<'a>(
        &self,
        layers: &KVSClusters<'a>,
        operations: Stream<KVSOperation<V>, Process<'a, ()>, Unbounded>,
    ) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    {
        let my_cluster = layers.get::<Name>();
        // Special-case: real Paxos wiring using auxiliary proposer/acceptor clusters
        let routed = if std::any::TypeId::of::<D>()
            == std::any::TypeId::of::<crate::dispatch::ordering::PaxosDispatcher<V>>()
        {
            wire_paxos_layer_from_process(
                &self.dispatch,
                layers,
                operations,
                my_cluster,
            )
        } else {
            self.dispatch.dispatch_from_process(operations, my_cluster)
        };
        self.child.wire_from_cluster(layers, my_cluster, routed)
    }

    fn wire_from_cluster<'a>(
        &self,
        layers: &KVSClusters<'a>,
        source_cluster: &Cluster<'a, crate::kvs_core::KVSNode>,
        operations: Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>,
    ) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    {
        let my_cluster = layers.get::<Name>();
        let routed = if std::any::TypeId::of::<D>()
            == std::any::TypeId::of::<crate::dispatch::ordering::PaxosDispatcher<V>>()
        {
            wire_paxos_layer_from_cluster(
                &self.dispatch,
                layers,
                source_cluster,
                operations,
                my_cluster,
            )
        } else {
            self.dispatch
                .dispatch_from_cluster(operations, source_cluster, my_cluster)
        };
        self.child.wire_from_cluster(layers, my_cluster, routed)
    }
}

fn wire_paxos_layer_from_process<'a, V, D: Clone>(
    _dispatch: &D,
    layers: &KVSClusters<'a>,
    operations: Stream<KVSOperation<V>, Process<'a, ()>, Unbounded>,
    target_cluster: &Cluster<'a, crate::kvs_core::KVSNode>,
) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
where
    V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    KVSOperation<V>: crate::dispatch::ordering::paxos_core::PaxosPayload,
{
    use crate::dispatch::ordering::paxos_core::{paxos_core, Acceptor, Proposer};
    // Fetch aux clusters
    let proposers = layers.get_aux::<Proposer>();
    let acceptors = layers.get_aux::<Acceptor>();

    // Demux client ops to proposers (member 0)
    let ops_to_proposers = operations
        .map(q!(|op| (hydro_lang::location::MemberId::from_raw(0u32), op)))
        .into_keyed()
        .demux_bincode(proposers)
        .values();

    let acceptor_tick = acceptors.tick();
    let a_checkpoint = acceptor_tick.optional(q!(/** no checkpoints initially */ None::<usize>));

    let (_ballots, sequenced) = paxos_core(
        proposers,
        acceptors,
        a_checkpoint,
        move |_ballots| ops_to_proposers,
        crate::dispatch::ordering::PaxosConfig::default(),
        nondet!(/** leader election nondet */),
        nondet!(/** commit nondet */),
    );

    // sequenced: Stream<(usize, Option<KVSOperation<V>>), Cluster<Proposer>, ...>
    // Filter holes, drop slot, forward to replica cluster (member 0)
    sequenced
        .filter_map(q!(|(_slot, maybe_op)| maybe_op))
        .map(q!(|op| (hydro_lang::location::MemberId::from_raw(0u32), op)))
        .into_keyed()
        .demux_bincode(target_cluster)
        .values()
        .assume_ordering(nondet!(/** paxos hop to replicas */))
}

fn wire_paxos_layer_from_cluster<'a, V, D: Clone>(
    _dispatch: &D,
    layers: &KVSClusters<'a>,
    _source_cluster: &Cluster<'a, crate::kvs_core::KVSNode>,
    operations: Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>,
    target_cluster: &Cluster<'a, crate::kvs_core::KVSNode>,
) -> Stream<KVSOperation<V>, Cluster<'a, crate::kvs_core::KVSNode>, Unbounded>
where
    V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    KVSOperation<V>: crate::dispatch::ordering::paxos_core::PaxosPayload,
{
    use crate::dispatch::ordering::paxos_core::{paxos_core, Acceptor, Proposer};
    let proposers = layers.get_aux::<Proposer>();
    let acceptors = layers.get_aux::<Acceptor>();

    let ops_to_proposers = operations
        .map(q!(|op| (hydro_lang::location::MemberId::from_raw(0u32), op)))
        .into_keyed()
        .demux_bincode(proposers)
        .values();

    let acceptor_tick = acceptors.tick();
    let a_checkpoint = acceptor_tick.optional(q!(/** no checkpoints initially */ None::<usize>));

    let (_ballots, sequenced) = paxos_core(
        proposers,
        acceptors,
        a_checkpoint,
        move |_ballots| ops_to_proposers,
        crate::dispatch::ordering::PaxosConfig::default(),
        nondet!(/** leader election nondet */),
        nondet!(/** commit nondet */),
    );

    sequenced
        .filter_map(q!(|(_slot, maybe_op)| maybe_op))
        .map(q!(|op| (hydro_lang::location::MemberId::from_raw(0u32), op)))
        .into_keyed()
        .demux_bincode(target_cluster)
        .values()
        .assume_ordering(nondet!(/** paxos hop to replicas */))
}

// Base case: terminal `()`
impl<V> KVSSpec<V> for () {
    fn create_clusters<'a>(
        &self,
        flow: &hydro_lang::compile::builder::FlowBuilder<'a>,
        _layers: &mut KVSClusters<'a>,
    ) -> Cluster<'a, crate::kvs_core::KVSNode>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    {
        // Terminal case: create a single cluster for the final storage layer
        flow.cluster::<crate::kvs_core::KVSNode>()
    }
}

// Recursive case: KVSCluster
impl<V, Name, D, M, Child> KVSSpec<V> for KVSCluster<Name, D, M, Child>
where
    Name: 'static,
    V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    D: OpDispatch<V> + Clone,
    M: ReplicationStrategy<V> + Clone,
    Child: KVSSpec<V>,
{
    fn create_clusters<'a>(
        &self,
        flow: &hydro_lang::compile::builder::FlowBuilder<'a>,
        layers: &mut KVSClusters<'a>,
    ) -> Cluster<'a, crate::kvs_core::KVSNode>
    where
        V: Clone + serde::Serialize + for<'de> serde::Deserialize<'de> + Send + Sync + 'static,
    {
        // Create this layer's own physical cluster and register under its Name.
        let my_cluster = flow.cluster::<crate::kvs_core::KVSNode>();
        layers.insert::<Name>(my_cluster.clone());
        // If dispatcher is Paxos, create auxiliary proposer/acceptor clusters.
        if TypeId::of::<D>()
            == TypeId::of::<crate::dispatch::ordering::PaxosDispatcher<V>>()
        {
            let proposers = flow.cluster::<crate::dispatch::ordering::paxos_core::Proposer>();
            let acceptors = flow.cluster::<crate::dispatch::ordering::paxos_core::Acceptor>();
            layers.insert_aux::<crate::dispatch::ordering::paxos_core::Proposer>(proposers);
            layers.insert_aux::<crate::dispatch::ordering::paxos_core::Acceptor>(acceptors);
        }
        // Recursively create child clusters (side effects register them) and ignore returned value.
        let _child_entry = self.child.create_clusters(flow, layers);
        // Return this layer's cluster as entry point for upstream operations.
        my_cluster
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::dispatch::SingleNodeRouter;
    use crate::maintenance::NoReplication;

    struct TestLayer;

    #[test]
    fn layer_creation() {
        let _layer = KVSCluster::<TestLayer, SingleNodeRouter, NoReplication, ()>::new(
            SingleNodeRouter,
            NoReplication,
            (),
        );
    }

    #[test]
    fn layer_default() {
        let _layer = KVSCluster::<TestLayer, SingleNodeRouter, NoReplication, ()>::default();
    }

    #[test]
    fn layers_lookup() {
        let layers = KVSClusters::new();
        // Can't easily test insert/get without a real FlowBuilder
        // Just verify the API compiles
        assert!(layers.try_get::<TestLayer>().is_none());
    }
}
